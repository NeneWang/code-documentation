import{_ as a,r as n,o as r,c as s,a as e,b as t,d as l,e as o}from"./app-DQekuI1D.js";const u={},c=o(`<h2 id="_1-master-algorithms-daily" tabindex="-1"><a class="header-anchor" href="#_1-master-algorithms-daily"><span>1 Master Algorithms Daily</span></a></h2><ul><li><ol><li>Is likely that you wont be using algorithms on your job (or at least not in the hard complexity ones.)</li></ol><ul><li>But on your journey to learning algorithms, You will learn the skill of problem solving throguht pattern recognition.</li><li>This is a significantly useful skill, as in software following patterns for solutions leads to optimized, mantainable, efficient strategies based where you can share and have at the same time an efficient solution.</li></ul></li><li><ol start="2"><li>If you havent started, go throguht the 150 recommended lists.</li></ol><ul><li>Give yourself 20-30 minutes to struggle with the problem</li><li>Watch a video/editorial solution for it. (even if you were able to solve it)</li><li>Dont prioritize learning the most optimal solution, but the solution that uses the <code>pattern</code> you are aiming to understand. Tackle the pattern &gt; Tackle the most efficient way to solve it.</li></ul><ol start="3"><li>Try replicating the solution from memory then Go to</li></ol><ul><li>Do 1 similar problem. (easier is okay) The idea is for you to <strong>understand</strong> that pattern.</li></ul></li><li><ol start="4"><li>Once you complete 150 go to daily algorithmic problems.</li></ol></li><li><ol start="5"><li>Study and Document the most Impactful Algorithms used on the industry, Note below a project to take you to key algorithms</li></ol></li></ul><p><strong>Projects</strong></p><p>For [5] Consider the following key-algorithms. Learn them by heart by documenting, doing charts.</p><p>Sources http://www.koutschan.de/misc/algorithms.php</p><p><strong>Some of the key Algorithms Areas</strong></p><ul><li><p>Machine learning and Optimization</p><ul><li>Gradient Descent</li><li>Genetic Algorithms</li></ul></li><li><p>Database Algorithms</p><ul><li>BTree and B+ Tree</li><li>Consistent Hashing</li></ul></li><li><p>Cryptography</p></li><li><p>Sorting and Searching</p><ul><li>Quicksort</li><li>Binary Search Tree Algorithm</li></ul></li><li><p>Graph Algorithms</p></li><li><p>Data Compression</p><ul><li>Lempel Ziv Welch</li><li>Brotli</li></ul></li><li><p>Optimization and Scheduling</p><ul><li>Simulated Annealing</li><li>Linear Programming</li></ul></li><li><p>Artificial Intelligence</p><ul><li>Hidden Markov Models</li><li>BERT (Bidirectional Encoder Representations from Transformers)</li></ul></li><li><p>Languge Processing</p></li><li><p>Data Structures and Algorthms</p><ul><li>Red Black Trees</li><li>Bloom filters</li></ul></li><li><p>Cryptographic and Blockchain</p><ul><li>Elliptic Curve Cryptography (ECC)</li><li>Blockchain Consensus Algorithms</li></ul></li><li><p>Computational Geometric and Graphics</p><ul><li>Ray Tracing Algorithms</li><li>Maarching Cubes Algorithms</li></ul></li><li><p>Distributed Computing and Systems</p><ul><li>Map Reduce</li><li>Paxos Algorithms</li></ul></li><li><p>Euclid</p></li><li><p>nicomachus examples</p></li><li><p>Sieve of Eratosthenes</p></li><li><p>QR Algorithms for Computing Eigenvalues</p></li><li><p>Quicksort</p></li><li><p>heapsort</p></li><li><p>jpeg compression</p></li><li><p>Fast Fourier Transform</p></li><li><p>Dijikstra Algorithm</p></li><li><p>RSA Algorithm</p></li><li><p>Secure Hash Algorithm</p></li><li><p>Integer Factorization</p></li><li><p>Link Analysis</p></li><li><p>Proportional Integral Derivative Algorithm</p></li><li><p>Data Compression Algorithms</p></li><li><p>Random Number Generation</p></li><li><p>A* Search Algorithm</p></li><li><p>Beam Search</p></li><li><p>Binary Search</p></li><li><p>Branch and Bound</p></li><li><p>Bunchberger&#39;s Algorithm</p></li><li><p>Data Compression</p></li><li><p>Diffie-Hellman Key Exchange</p></li><li><p>Discrete Differentiation</p></li><li><p>Expectation Maximization Algorithm</p></li><li><p>Gradient Descent</p></li><li><p>Hashing</p></li><li><p>Heap Sort</p></li><li><p>Karatsuba Multiplication</p></li><li><p>LLL Algorithm</p></li><li><p>Maximum Flow</p></li><li><p>Newton&#39;s Method</p></li><li><p>Merge Sort</p></li><li><p>Q-Learning</p></li><li><p>Quadratic Sive</p></li><li><p>RANSAC</p></li><li><p>Schohange Strassen Algorithm</p></li><li><p>Simplex Algorithm</p></li><li><p>Singular Value Decomposition</p></li><li><p>Strukturtensor</p></li><li><p>Union Find.</p></li><li><p>Viterbi Algorihtm</p></li><li><p>KNN</p></li><li><p>Random Forest</p></li><li><p>Naive Bayes</p></li><li><p>Neural Network</p></li><li><p>Monte Carlo</p></li><li><p>MapReduce</p></li></ul><p>Try doing all problems in:</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>C++
Java
Python
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Why? Cause you need to practice those languages. Absolutely. You should consider doing all again (the 150 list) again in Java or C++</p><h2 id="_2-master-data-science-machine-learning-daily" tabindex="-1"><a class="header-anchor" href="#_2-master-data-science-machine-learning-daily"><span>2 Master Data Science + Machine Learning Daily</span></a></h2><ul><li>I dont care if this is wasn&#39;t your original goal. If you dont do it, you will eventually be replaced by someone who does.</li><li>Also a strong skill to have for your own projects and if you will start a business.</li></ul><h3 id="projects" tabindex="-1"><a class="header-anchor" href="#projects"><span>Projects</span></a></h3><ul><li>[Ideation]: Presentation Trainer Tool.</li></ul><h2 id="_3-how-to-successfully-learn-a-framework-language" tabindex="-1"><a class="header-anchor" href="#_3-how-to-successfully-learn-a-framework-language"><span>3 How to successfully learn a Framework/Language</span></a></h2><pre><code>When do you consider yourself good at a language?
</code></pre><ul><li><p>Because you can create a project with that? No</p></li><li><p>Because you have a job with that? No</p></li><li><p>Because you can solve problems with that? No</p></li><li><p>But because you can really understand whats the reason that language/framework and whats the cycle and context that langauge/framework/environment supports and the best practices on it.</p></li><li><p>When you are using a language framework, always try to learn it&#39;s best practices</p></li><li><p>Otherwise you are not really learning the <code>pattern</code> of the language.</p></li><li><p>This usually involves:</p></li></ul><ol start="2"><li>Best Practices goals</li></ol><ul><li>File Structure <ul><li>Usually because of a reason, where do you organize components/ Whats the hierarchy of files? What files to ignore, where to write your environment variables, etc.</li></ul></li><li>Naming Conventions <ul><li>Key, do it use camelCase? PascalCase? snake_case? kebab-case? What are the best practices for naming variables, functions, classes, etc.</li></ul></li><li>Code Style <ul><li>How are classes organized? How are functions organized? How are variables organized? How are comments organized?</li></ul></li><li>Testing <ul><li>Whats the CD CI Pipeline strategy for this framework? Is this more of an UI testing? Unit testing? No testing? Whats the best practice when it comes to organizing</li></ul></li><li>Documentation Strategy <ul><li>Deployment Strategy. Many languages allow for in-code documentation, to auto-produce documentation files. Take advantage of that. Try to use that support on each language/framework.</li><li>Different Languages have different documentation strategies that are optimized for that tool&#39;s objective, be it building visual components, enhancing test documentation, etc.</li></ul></li><li>Development Cycles Practices for that language/framework <ul><li>Whats the initial mock and requirement listing</li></ul></li><li>Common Design Patterns on that language. <ul><li>Whats the pattern used for that language in specific? Why that design pattern helps?</li></ul></li></ul>`,19),h={start:"3"},p=e("li",null,"Create a project with that framework",-1),d=e("li",null,"Master the best practices of that framework in one project",-1),g={href:"https://www.atlassian.com/git/tutorials/merging-vs-rebasing",target:"_blank",rel:"noopener noreferrer"},m={href:"https://realpython.com/tutorials/advanced/",target:"_blank",rel:"noopener noreferrer"},y=e("li",null,"Create a library for that Framework (It can be forking, and creating at least 1 feature there.)",-1),f=o('<h2 id="_4-going-through-trainning-as-an-engineer-mentality" tabindex="-1"><a class="header-anchor" href="#_4-going-through-trainning-as-an-engineer-mentality"><span>4 Going through Trainning as an Engineer Mentality</span></a></h2><ol><li>College courses, bootcamp, online course follow the following pattern</li><li>Develop Flashcards based on the best practices listed above so you dont forget them.</li><li>Create tasks cards for future practice so that you can train yourself into using those cases. <ul><li>For example you are learning react, you should create a card and git repo for a project start and how the project should look at the project finish.</li><li>For data sicnece you should allow for the same project ideation style.</li></ul></li><li>If you are doing a Masters/Phd then for each of the classes you should contribute on an open source project related to that class. (Creating your own is okay)</li></ol><h3 id="project" tabindex="-1"><a class="header-anchor" href="#project"><span>Project</span></a></h3><ul><li><p>Presentation Task Oriented Tool for [3]:</p><ul><li>This tool should allow for users to create their own tasks.</li><li>Time limit them so that a task</li><li>When creating a task <ul><li>Suggested time limitation for the task</li></ul></li></ul></li><li><p>Mastery CLI for [2]</p><ul><li>Should be able to share their deck of cards.</li><li>Should be allowed for free</li></ul></li></ul><h2 id="_5-building-a-reputation-for-consistency" tabindex="-1"><a class="header-anchor" href="#_5-building-a-reputation-for-consistency"><span>5 Building a reputation for Consistency</span></a></h2><ul><li><ol><li>You should be able to show that you are consistent in your work and software that contains heatmaps or streak recordings are usually one of the bests.</li></ol></li><li><ol start="2"><li>Use github, publish almost daily, participate on projects, create followers, follow me, I will follow you automatically.</li></ol></li><li><ol start="3"><li>Use Leetcode, publish daily, dont be like me that didnt use that much, because of fear of not being able to use them.</li></ol></li><li><ol start="4"><li>Message your boss at least once, and each member of the team, invent an excuse, any works</li></ol><ul><li>Design thoughts.</li><li>A new library you found that might be applicable.</li></ul></li></ul><h2 id="_6-passively-learning-cyber-security-it" tabindex="-1"><a class="header-anchor" href="#_6-passively-learning-cyber-security-it"><span>6 Passively Learning Cyber Security + IT</span></a></h2><p><em>The idea is to passively getting better at cybersecurity. You might not need to implement the securities measures all the time. My suggestion would be to write this audits every 2-5 sprints. (Or once the software has been made into a stabilized)</em></p><ol><li>Regularly Documenting Vulnerabilities.</li></ol><ul><li>When learning a framework, or developing software, you should at the same time, practice cybersecutiy, by mantianning a log/documentation of the potential vulnerabilities of the system. e.g. Putting yourself in a hacker&#39;s shoes. How would you hack your own system?</li><li>Where to find the API keys?</li><li>How would you access infomration you are not supposed to?</li><li>How could I ssh this? How could I spoof a user admin?</li><li>What scripts could I write to automate the process of hacking this system?</li><li>What are the key people that could be targeted in this system? What kind of emails could be used?</li></ul><ol start="2"><li>Learn the basics of Cybersecurity <ul><li>Google Certificate.</li><li>Codepath, certificate.</li></ul></li></ol><p>Then continue by writting down the possible solutions to those vulnerabilities. The thing about this, is that you should create checklists based on what you learn from the basics, <em>lenses</em> that you should use on your own software. (Patterns of vulnerabilities)</p><ol start="3"><li>Cybersecurity is constantly changing, therefore is not worth, actively pursuing such, but is worth <em>actively</em> pursuing software developmenet with an eye on your defenses and vulnerabilities. Grow by understanding commonly used tools + patterns of vulnerabilities. And then using this tools in a cycle to audit your own software.</li></ol><h2 id="_6-passion-projects" tabindex="-1"><a class="header-anchor" href="#_6-passion-projects"><span>6 Passion Projects</span></a></h2><p>Key points:</p><ul><li>Documentate for Explainning</li><li>Encapsulate Templates for Reusability</li><li>Building Libraries shows expertise of that framework (usually)</li></ul><p>Why?</p><ul><li>You need to get paid</li><li>You can increase your popularity by making reusable code (Also a good talking point).</li></ul><ol><li>Make software Projects that can be shown to recru <ol><li>Keep in readme the sets of Install options and descriptions with pictures and captures of it&#39;s features.</li><li>Create a <code>highlight.md</code> file tracking the progression of your software and HIGHLIGHT whenever you face an interesting challange.</li></ol></li><li>Once you have a project done, dont let it stay like that, build a library/template out of it. <ol><li>The entire project doesn&#39;t require to become a library, but aim to create a library from one of the complex parts of the project.</li><li>And attempt if you have not yet, create a template (for Hackathons or other similar organizations) by abstracting the project into a template.</li><li>Make reference of the third tools that you created out of them.</li><li>Logic Abstaction: Perhaps the Logic can be abstracted into an API, or a graphing terminal tol can be abstracted into a terminal package.</li><li>Architecture Abstraction: Perhaps the authentication System can be abstracted.</li><li>UI Abstraction: Perhaps the UI can be abstracted into an UI library.</li></ol></li></ol><h2 id="_7-language-mastery" tabindex="-1"><a class="header-anchor" href="#_7-language-mastery"><span>7. Language Mastery</span></a></h2><p>Here 3 layers for the mastery of that Language:</p><ol><li>Build a project with that language</li><li>Finish 1 leetcode problem (easy) of each pattern using that language</li><li>Finish 1 leetcode problem (medium) of each pattern using that language</li><li>Fork and create an open source library for that language (raw, it can be forked, thats okay)</li></ol><p>Once you are able to complete the 3 layers, you can consider yourself a master of that language.</p><h2 id="_8-work-and-personal-projects" tabindex="-1"><a class="header-anchor" href="#_8-work-and-personal-projects"><span>8. Work and Personal Projects</span></a></h2><p>If you were to follow this commandmnets, no matter the pay, you would still be increasing your knowledge worth and also have a interestingly perhaps profittable side project.</p><ul><li>As well as a non-binded project that you could use to show your skills to your future employer.</li></ul><ol><li>You should strive to build your own <code>mini-scaled</code> version on your personal project of the software you are working on at work. <ol><li>Your objective here is not to biuld the competition, but actually make more insight s to also become better at your <code>job</code>.</li><li>Here you will have the liberty of exploring your own algorithms and libraries.</li><li>Try if you can, to consider using your own models (based on your prefferences)</li><li>Use your job also as a learning opportunity to learn the best practices of the language and framework you are using.</li><li>Also you wouldn&#39;t need to worry about the constant business requirmenet changes.</li></ol></li></ol><h2 id="_9-taking-your-company-success-personally" tabindex="-1"><a class="header-anchor" href="#_9-taking-your-company-success-personally"><span>9. Taking your Company success personally</span></a></h2><p><em>Recommended for once you have 1-2 yoe. This is the real mastery of your tasks before anything else. And then using that to leverage your voice inside of the decision mking.</em></p><ol><li>Instead of living a life of trying to jump ships. There is something very interesting about the software engineer role in the position. <ol><li>This means, taking a higher higher risks, suggesting and making bold responsabilities claims.</li></ol></li><li>Before you talk you need to build-up your credentials: <ol><li>Ensure that your code is fully tested/rid of bugs. (Do your job perfectly.)</li><li>Make sure your code is fully documented (diagrams, naming conventions, etc)</li><li>Empty the bucket of tasks to be done.</li><li>Always prepare a looking-forward feature suggestion presentation with you.</li></ol></li><li>This is a second layer of to-dos, once the above is done. Which is proactive. <ol><li>Prepare for certifications related to the technology or framework being touched</li><li>Attempt to contribute open-source, forking, and making templates/libraries depending on the indsutry needs of that project.</li></ol></li></ol><h2 id="_10-continuous-testing-at-your-advantage" tabindex="-1"><a class="header-anchor" href="#_10-continuous-testing-at-your-advantage"><span>10. Continuous Testing at your advantage.</span></a></h2><p><em>Use a continuous testing philosophy to advance on your knowledge (advanced technical) passively</em></p><p>This includes the following: ranked.</p><table><thead><tr><th>Topic</th><th>Value Est.</th></tr></thead><tbody><tr><td>Study for certifications: aws, certifications</td><td>9</td></tr><tr><td>Interview questions of specific language/technology</td><td>9</td></tr><tr><td>Introduction to algorithms</td><td>8</td></tr><tr><td>Machine learning</td><td>8</td></tr><tr><td>Programming Best Practices: Design Patterns, Testing</td><td>7</td></tr></tbody></table><p>Here so guidelines into building great flashcards:</p><ul><li>They dont ask you the definition, but how could you use X technology</li><li>If it is about implementation, provides an example of how to implement it (use it for refreshing a tech aspect)</li></ul><h2 id="_11-documentation" tabindex="-1"><a class="header-anchor" href="#_11-documentation"><span>11. Documentation</span></a></h2><ol><li>Attempt to follow auto documentation for each langauge format of documentation (close to code for methods)</li><li>Keep a datastructure table excel or draw.io with also how classes interact with each, and responsabilities. (Note you can have the following also as a single Google docs, if it is easier. (Always try to keep thing stogether/)) <ol><li>Google Sheet Tab with table with Tests.</li><li>Google sheet Tab with features, coverage to have, difficulty, KPI, Need matrix, Status, Catgory (e.g. template, Third party.)</li><li>Google Sheet Tab with each datastructure and database models being used.</li><li>Google Sheet Tab with API documentation and implementation.</li></ol></li><li>Keep <strong>highlight</strong> section for story telling of this project.</li><li>Keep futureistic as possible the readme with even features it doesn&#39;t have. But you are planning to have. (for visitors mostly)</li><li>Dcoument deployment with dockerfile/makefile in code.</li><li>For Database Models, always go for keeping a coded model, so you can write comments regarding each change and run migrations automatically.</li></ol>',38);function b(w,k){const i=n("ExternalLinkIcon");return r(),s("div",null,[c,e("ol",h,[e("li",null,[t("Steps of the mastery of frameworks: "),e("ol",null,[p,d,e("li",null,[t("Finish 10 Advanced guide (or a book worth of content) of that framework (or language) "),e("ol",null,[e("li",null,[e("a",g,[t("Exhibit 1: Advanced Git: Merging vs Rebasing"),l(i)])]),e("li",null,[e("a",m,[t("Exhibit 2: Real Python Advanced"),l(i)])])])]),y])])]),f])}const _=a(u,[["render",b],["__file","software.html.vue"]]),j=JSON.parse('{"path":"/posts/guide/software.html","title":"Mastery of Software Development","lang":"en-US","frontmatter":{"title":"Mastery of Software Development"},"headers":[{"level":2,"title":"1 Master Algorithms Daily","slug":"_1-master-algorithms-daily","link":"#_1-master-algorithms-daily","children":[]},{"level":2,"title":"2 Master  Data Science + Machine Learning Daily","slug":"_2-master-data-science-machine-learning-daily","link":"#_2-master-data-science-machine-learning-daily","children":[{"level":3,"title":"Projects","slug":"projects","link":"#projects","children":[]}]},{"level":2,"title":"3 How to successfully learn a Framework/Language","slug":"_3-how-to-successfully-learn-a-framework-language","link":"#_3-how-to-successfully-learn-a-framework-language","children":[]},{"level":2,"title":"4 Going through Trainning as an Engineer Mentality","slug":"_4-going-through-trainning-as-an-engineer-mentality","link":"#_4-going-through-trainning-as-an-engineer-mentality","children":[{"level":3,"title":"Project","slug":"project","link":"#project","children":[]}]},{"level":2,"title":"5 Building a reputation for Consistency","slug":"_5-building-a-reputation-for-consistency","link":"#_5-building-a-reputation-for-consistency","children":[]},{"level":2,"title":"6 Passively Learning Cyber Security + IT","slug":"_6-passively-learning-cyber-security-it","link":"#_6-passively-learning-cyber-security-it","children":[]},{"level":2,"title":"6 Passion Projects","slug":"_6-passion-projects","link":"#_6-passion-projects","children":[]},{"level":2,"title":"7. Language Mastery","slug":"_7-language-mastery","link":"#_7-language-mastery","children":[]},{"level":2,"title":"8. Work and Personal Projects","slug":"_8-work-and-personal-projects","link":"#_8-work-and-personal-projects","children":[]},{"level":2,"title":"9. Taking your Company success personally","slug":"_9-taking-your-company-success-personally","link":"#_9-taking-your-company-success-personally","children":[]},{"level":2,"title":"10. Continuous Testing at your advantage.","slug":"_10-continuous-testing-at-your-advantage","link":"#_10-continuous-testing-at-your-advantage","children":[]},{"level":2,"title":"11. Documentation","slug":"_11-documentation","link":"#_11-documentation","children":[]}],"git":{"updatedTime":1710257900000,"contributors":[{"name":"NelsonWang","email":"wangnelson2@gmail.com","commits":2}]},"filePathRelative":"posts/guide/software.md","excerpt":"<h2>1 Master Algorithms Daily</h2>\\n<ul>\\n<li>\\n<ol>\\n<li>Is likely that you wont be using algorithms on your job (or at least not in the hard complexity ones.)</li>\\n</ol>\\n<ul>\\n<li>But on your journey to learning algorithms, You will learn the skill of problem solving throguht pattern recognition.</li>\\n<li>This is a significantly useful skill, as in software following patterns for solutions leads to optimized, mantainable, efficient strategies based where you can share and have at the same time an efficient solution.</li>\\n</ul>\\n</li>\\n<li>\\n<ol start=\\"2\\">\\n<li>If you havent started, go throguht the 150 recommended lists.</li>\\n</ol>\\n<ul>\\n<li>Give yourself 20-30 minutes to struggle with the problem</li>\\n<li>Watch a video/editorial solution for it. (even if you were able to solve it)</li>\\n<li>Dont prioritize learning the most optimal solution, but the solution that uses the <code>pattern</code> you are aiming to understand. Tackle the pattern &gt; Tackle the most efficient way to solve it.</li>\\n</ul>\\n<ol start=\\"3\\">\\n<li>Try replicating the solution from memory then Go to</li>\\n</ol>\\n<ul>\\n<li>Do 1 similar problem. (easier is okay) The idea is for you to <strong>understand</strong> that pattern.</li>\\n</ul>\\n</li>\\n<li>\\n<ol start=\\"4\\">\\n<li>Once you complete 150 go to daily algorithmic problems.</li>\\n</ol>\\n</li>\\n<li>\\n<ol start=\\"5\\">\\n<li>Study and Document the most Impactful Algorithms used on the industry, Note below a project to take you to key algorithms</li>\\n</ol>\\n</li>\\n</ul>"}');export{_ as comp,j as data};
