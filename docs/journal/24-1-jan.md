---
title: January 2024
---

### 05 - Fri

I cant believe it, I am back.

- A lot of stuff happened. What I am hopping to do is to take the largest share of advantage from the point I am in right now. And focus to learn and improve on the areas that appear to most significantly tbe improving upon my career. I gonna also make sure that the Mastery system is or will be also improved to the point I can confintly run the practce problems. 


### 5.todo

- [x] 5.1 Improving Mastery System.
- [x] 5.2 Identifying the co-beneffited areas 
- [x] 5.3 Identifying what are the procedures to follow for the mastery of each item.
- [x] 5.4 How about the long term web design objectives?
- [x] 5.5 Working on designing the Jupyter Notebook series practice
- [ ] 5.6 Start designing the project to record the presentation practicing project




### 5.2 Identifying the co-beneffited areas

- [ ] What are the areas that are good for my career and perphaps might appear on the future current job description or dailies?
- [ ] Rank in which order to run the probabilities of them.



- [ ] 1. Managing a Team
- [ ] 2. AWS 
- [ ] 3. Ai 
  - [ ] 3.1. Machine Learning for predicting patterns.
  - [ ] 3.2 Language Processing.
- [ ] 4. Data Structures and Algorithms.
- [ ] 5. Designing Systems and Architecture Design
  - [ ] 5.1 Database Design
  - [ ] 5.2 System Design
  - [ ] 5.3 AWS Architecture Design
- [ ] 6. TDD
  - [ ] Test Kit Best practices.
- [ ] 7. Recognition patterns


### 5.1 Improving the Mastery System

- [ ] Adding default disabled flags for math and non terminology problems.
- [ ] So now it will require the `--all` flag if the dsa problem is to be desired. This is so that the optimiazation

- This fixture requires for the flags

```js

if (flags.all) {
    console.log("all")
    const problem_response = await dsaTrainer.showMenuOfProblems();
    updateAlgorithmPerformance(problem_response);
} else {
    const problem_response = await dsaTrainer.showRecommendedProblems();
    updateAlgorithmPerformance(problem_response);
}


```


### 5.3 Identifying what are the procedures to follow for the mastery of each item.

**Practices Related Areas**

*Here are areas that require the intended practice on the daily, such as running algorithms and practicing AI Modeling using some data Science Library.*


**Best Practices Knowledge Areas**

*Here is a matter of practicign with the daily commits. *

- I am in fact considering removing data structures practices from the random problems because they bring those problems of slowering work.
- And also deleting the math problems as they dont belong to the opportunity for daily practice. Most of them are just basic computing does it make sense to have them there? The only reasonable ones are the ones running with discrete math inside of them. (Including probability?)
- As for Data Strucutre + Practice problems what I am hoping to have is that whenever you are coming back in train or in the train your practice should focus on the areas closer to the requried "practice areas": this can be done by having the dsa practice challange being requested at the end of the day, and either practice for ANKI or for CSE or for CSJ: Continues Sequence Jupyter where you have distinct problems for data Jupyter Notebooks AI related problems.


**Mantainanace Areas**



**Things to be practiced at home**

- Well then at home you shall do tutorials. 
- .net projects
- Freelance projects etc.
- Building Portfolio Projects




### 5.4 How about the long term web design objectives?


They shall contain the following since some skills are better shown with some proofs

For Abstract skills such as AI and AWS they shall be shown throgh certificates:

- AWS Certificte: EMR + redshift + Snowflake
- Google Tensorflow Certificate
- Azure Certificate

While others shall be show with the actual projects for them:

- .net
- Spring

Those two are actually the largest one bothering me.

Kind of nonsenseless. 


Here how the other habits shall be split for 



#### Habits that should be done on the daily basis 


**Practice English on the daily basis**

This can be broken down on the following habits:

- Do a research Short with 30 minutes and 5 minutes presentation for random topics


**Applying everyday for programs**

- This gets harder as you might have to be away of work to interview.
- This can be done while doing other stuff like going to gyb

**Working out everyday**

- This can be done by watching series while working out. As far as I am aware is a very effective method.


### Todays and this weekends plan of actions:

- Continue working on ALL projects this includes (portfolio, and Prometheus and Freelance Sister)

These should be the habits to be added:

- Work
- Have 1 series + trainning
- Have 2 blocks of Projects



**Ideally at work**

- if there is work to do, complete your work.
- Otherwise take advantage to ontinue improving your personal tools. (Never do tutorials as it looks bad)
- If no motivation whatsoever follow cses and jses routines.



### 5.5 Working on designing the Jupyter Notebook series practice

- It opens and now copies the file direction to the clipboard, but what we want from it is to copy it's content to a raw file that should be used as temp for solving it.

1. Copy raw file

Lets check how this is done:

```js
 populate_problem = true,
populate_with_cloze_filepath = "", base = "" } = {}) {
if (populate_problem) {

    if (populate_with_cloze_filepath != "") {

        this.problems_manager.populateTemplate({ file_path: populate_with_cloze_filepath }, { base: base });
    } else {

        this.problems_manager.populateTemplate(problem);

    }
}
```

```js

    if (base != "") {
        return this.copyFileToTemp(problem.file_path, { base: base });
    }
    this.copyFileToTemp(problem.file_path);

```

This is what we want to copy from:


```js title="dsa-cli/problems-manager.js"


/**
 * Copies the file from problem_file_path to the temp_problem_filepath.
 * @param {str} problem_file_path The path to the file to copy
 * @param {str} base The path to the file to copy from e.g. base_code'
 */
copyFileToTemp(problem_file_path, { base = "./base_code/" } = {}) {
    try {
        // console.log("Copying file from", problem_file_path, "to", this.temp_problem_filepath)
        const absolute_problem_file_path = getDirAbsoluteUri(problem_file_path, base);
        const absolute_temp_file_path = getDirAbsoluteUri(this.temp_problem_filepath, "./");


        // console.log("Opening file: " + absolute_problem_file_path, "from source,", problem_file_path);
        fs.readFile(absolute_problem_file_path, 'utf8', function (err, data) {
            if (err) {

                console.log(err)
                return false
            }

            fs.writeFile(absolute_temp_file_path, data, 'utf8', function (err) {
                if (err) {
                    console.log(err)
                    return false
                };

            });
        });
        return true;
    } catch (err) {
        console.error(err);
        return false;

    }
}

```

You read the file and then you write it to make it work just fine.


## 5.6 Start designing the project to record the presentation practicing project

I know that the design features includes:

- [x] 1. A way to record the presentation
- [x] 2. Storing of the presentations
- [x] 3. A way to play the presentation
- [x] 4. A way to play the presentation with the timer


What I want to focus on now is the random presentation generator, and the architecture to store the presentations. (either as a file or as on the database.)

How to create a quick prototype for it?

- Using Youtube to upload the video. Which can be uploaded as a private link. Then just store the private link key on the database. That should be enough.

Lets create an actual prototype for this:

As for the database I can use something I had already been using. Finally enoguh that can just be the prototype which meanss you would be instead in charge of the following:


- [x] Developing a timer
- [x] Developing a randomizer of prompts as a Rogue Like where the user can choose
- [x] Finished Recording Time
  


Features of the Video Memory:
- which topic it belongs to
- How long?
- Grade
- Which user belongs to.
- Time that took required for preparing
- When it was being selected (start_ch_time)


Should there be an option for going over these again?


Topic Features
- Title
- Difficulty
- Expected preparation time
- Categories: e.g. business etc

I am thinking of straight adding the strings instead? so there are no borig joins. but I agree that still needed.

Also category

https://app.diagrams.net/#G1dBLbwRWmtB2V1uJhricZBCyXAEZr1rLU


The problem with this competition is that you are expected to act honorifically and record and upload exactly during the expected period.

![](./../.vuepress/public/img/2024-01-05-14-59-21.png)

Now tht we have the basic designs we shoudl start developig the ste. As for stacks, I am thinking of using such as:

- React + Python for backend.


### Designing the Trello Cards Built Site

- [x] This optimization however requires of a redesign of the homepage also for the individual productivity


- At the end of the day it should count the amount of cards completed



### Design Page for Your own Performance Section


Features

- [ ] It should encourage the following habits:
  - [ ] 2 blocks Focusmate Completed - From API
  - [ ] At least some algorithms being done - from Own API
  - [ ] At least 3 Trello Cards Completed. - From Trello Automation API.



Other habits that would be nice to have marked as well:

- Upload of daily Presentation Practice video.
- Somehow know whenever I have my workout done.

This includes what might be as a video for 


What to display?

*The objective is to get work done by constantly having a place where to checkup on. This can be a heatmap, or because of the self encouragement of the *

- What days have we been running work on? (like the last 3)
- There has to be a way so that it is integrated on the daily routine from      


## 8th - Monday

### 8.todo 


- [x] 8.1 Evuating Journaling system
- [x] 8.2 Adding the X whenever is Negative to signify that it has already been done
- [ ] 8.3 Developing the actual Journaling System.
- [ ] 8.4 Designing and Developing the 


### 8.1 Evuating Journaling system

- The idea is to have a system whereas you can enter and focus what to do and what is your objective you want to obsess with by the end of the year. What do you want in `365` days?

Definitevely if you want to get a more p* 

- More Fluent English
- Amazing Portfolio

Those are the things you want to obsess over with.


Whats the technical challange you are aiming to achieve?

These are all projects that can be achieved throught the already work being done.

- Data Science Project => Create 30 minutes presentations about a pcertain case.
- Data Strucutres Project => 
- Flutter Project => Publish your own app there.
- IOS + Android Project
- Interesting React Project containing Cool Animations.


While at work is more about getting the following objectives

- AWS Expertise


For the Journaling System it could be the first COA of the day to be asigned automatically to journlaing


- [x] Create a Journaling Database


Whats the idea of the Journaling system?

- The idea is that it

I wonder if this idea of just submitting is the right way to go. Using Leetcode from just on the daily work. On that fashion you could grind both ways and use work to 100% focus on improving your algorithms while being 100% efficient and top of your game at work.

Your objective is to prepare for the next job. And you are doing it by doing the following:

- Daily lc
- Daily Data Science Problems
- Daily Design questions (COA)
- Daily Practice with AWS Prompt problems.


## 9 - Tuesday

### 9.todo

- [x] 9.1 Planningn 


### 9.1 Planning

This is an iteration of the previous idea.

- For LC try to solve a medium new, 1 Medium Old + ~7 Cloze problems
- Also create a tracker for Jupyter problems.
- You can honestly ignore the hard questions



Could you perphaps doing the same with visualizations?

I think with that you should be having enough...


Like some kind of presentation master game where you have 
to find out which is the okayish way to re

Man, I had been practicing LC for a while, I know that this can be done, I am going to destroy the Algorithms class.

Now i need to start nailing that system design. I might not be 

## 10 - Wednesday

### 10.todo

- [x] 10.1 Mixing of Algorithms
- [ ] 10.2 Allow Reseeting 


### 10.1 Mixing of Algorithms

1. We know tha twe can find this in the main menu page This is run whenever we are attempting to open a new CSES Session. Therefore we see the mixing but ONLY if there is no

- Where is the Algorithms to find the if to create from zero is there?

### 10.2 Allow for Resetting

1. Adding resetting option for it, flag so that if detected, it will reset the progress of the algorithm.



As long a sthe `reset_scheduler` is true:

```js

async setLearningCards(cards, { cleanIfDifferent = true, onlyAddIfNotThere = true, loadLastCardsFirst = true, ask_if_to_use_old_queue = false, shuffle=false, reset_scheduler = false } = {}) {
...}

```


So now we have this working on the following:


```js

cloze_study_session = async ({reset_scheduler = false}) => {

    // Pick all the available string keys.

    await this.dsaTrainer.loaded_problem_manager;
    const cloze_problems = cloze_problems_list;
    const clozeScheduler = new TermScheduler({
        cards_category: "Algo"
    });
    await clozeScheduler.setLearningCards(cloze_problems, {shuffle: true, reset_scheduler: reset_scheduler});
    let exit = false;

    const printCardsLeft = (cardsLeft, cardsLearnt) => {
        console.log(`\nAlgorithms left: ${cardsLeft} || Algorithms completed: ${cardsLearnt}\n`);
    }

    while (!clozeScheduler.is_completed && !exit) {
        const [cardsLeft, cardsLearnt] = [clozeScheduler.getCardsToLearn(), clozeScheduler.getCardsLearnt()];

        const card = await clozeScheduler.getCard();
        let problem = this.dsaTrainer.problems_manager.getProblem(card.problem_slug);

        console.log("Card", card);
        problem.is_cloze = true;
        const solution_metadata = await this.dsaTrainer.solveProblem(problem, { base: DSAConstants.PATHS.base_cloze, populate_with_cloze_filepath: card.file_path });

        const answerIsCorrect = solution_metadata.status == DSAConstants.ProblemStatus.solved;
        clozeScheduler.solveCard(answerIsCorrect);
        await clozeScheduler.saveCards();
        printCardsLeft(cardsLeft, cardsLearnt);
    }
}
```


Adding for the January for them.

#### Is it always forcing the reset?

no, its just that it requires at least one problem to be solved in order to get to the next queue item.

### How about 


### wkout?

- Yea
- 1 wonder if th3 r34s0n th4t h4ck3rs us3d to wr1t3 lik3 thi5 w4s bec4use th3y h0p3d to avoid d3t3cti0n wh3n th3ir m4anupscr1pts w3r3 t0 b3 f0und 0ut. 1 m3an it would be interesting if I could wr1te down my notes in j4p4n3s3 thoguh.


### Building an Repetition Queue for Problems.

- The main features would need to have a queue structure to store the problems. 
- Check how term scheduler is used to store this data in DSA Trainer.


```js title="QuizzerWithDSA"


    cloze_study_session = async ({reset_scheduler = false}) => {

        // Pick all the available string keys.

        await this.dsaTrainer.loaded_problem_manager;
        const cloze_problems = cloze_problems_list;
        const clozeScheduler = new TermScheduler({
            cards_category: "Algo"
        });
        await clozeScheduler.setLearningCards(cloze_problems, {shuffle: true, reset_scheduler: reset_scheduler});
        let exit = false;

        const printCardsLeft = (cardsLeft, cardsLearnt) => {
            console.log(`\nAlgorithms left: ${cardsLeft} || Algorithms completed: ${cardsLearnt}\n`);
        }

        while (!clozeScheduler.is_completed && !exit) {
            const [cardsLeft, cardsLearnt] = [clozeScheduler.getCardsToLearn(), clozeScheduler.getCardsLearnt()];

            const card = await clozeScheduler.getCard();
            let problem = this.dsaTrainer.problems_manager.getProblem(card.problem_slug);

            console.log("Card", card);
            problem.is_cloze = true;
            const solution_metadata = await this.dsaTrainer.solveProblem(problem, { base: DSAConstants.PATHS.base_cloze, populate_with_cloze_filepath: card.file_path });

            const answerIsCorrect = solution_metadata.status == DSAConstants.ProblemStatus.solved;
            clozeScheduler.solveCard(answerIsCorrect);
            await clozeScheduler.saveCards();
            printCardsLeft(cardsLeft, cardsLearnt);
        }
    }

```

Here the side projects to start mantaining:
- Workout the following softwares:
  - Java: Spring Backend
  - .Net C# Backend

each to mantain the following:

```js
 const clozeScheduler = new TermScheduler({
            cards_category: "Algo"
        });
    await clozeScheduler.setLearningCards(cloze_problems, {shuffle: true, reset_scheduler: reset_scheduler});
    let exit = false;

    const printCardsLeft = (cardsLeft, cardsLearnt) => {
        console.log(`\nAlgorithms left: ${cardsLeft} || Algorithms completed: ${cardsLearnt}\n`);
    }

    while (!clozeScheduler.is_completed && !exit) {
        const [cardsLeft, cardsLearnt] = [clozeScheduler.getCardsToLearn(), clozeScheduler.getCardsLearnt()];

        const card = await clozeScheduler.getCard();
        let problem = this.dsaTrainer.problems_manager.getProblem(card.problem_slug);

        console.log("Card", card);
        problem.is_cloze = true;
        const solution_metadata = await this.dsaTrainer.solveProblem(problem, { base: DSAConstants.PATHS.base_cloze, populate_with_cloze_filepath: card.file_path });

        const answerIsCorrect = solution_metadata.status == DSAConstants.ProblemStatus.solved;
        clozeScheduler.solveCard(answerIsCorrect);
        await clozeScheduler.saveCards();
        printCardsLeft(cardsLeft, cardsLearnt);
    }
```

Fetch and use the TermScheduler for the cards category: ``


- Is missing how to add new cards.
- 


Actually I might just use this:


```js

class StorableQueue {
    constructor({ name = "" } = {}) {
        this.elements = [];
        this.name = name;
        this.absolute_uri = getDirAbsoluteUri(`temp/${this.name}`);
    }

    async load() {
        try {
            const { JsonDB, Config } = await import('node-json-db');

            const db = new JsonDB(new Config(this.absolute_uri, true, false, '/'));
            this.elements = await db.getData('/elements');
            console.log(`Loaded ${this.length} from ${this.name} | ${this.absolute_uri}`);
            return true;
        } catch {
            return false;
        }
    }

    async save() {
        const { JsonDB, Config } = await import('node-json-db');

        const db = new JsonDB(new Config(this.absolute_uri, true, false, '/'));
        db.push('/elements', this.elements);
    }

    cleanQueue() {
        this.elements = [];
    }

    has(element) {
        return this.elements.includes(element);
    }

    enqueue(element) {
        // If not undefined
        if (element)
            this.elements.push(element);
    }

    enqueueMultiple(elements) {
        for (const element of elements) {
            this.enqueue(element);
        }
    }

    dequeue() {
        const item = this.elements.shift();
        this.head = 0;
        return item;
    }

    peek() {
        return this.elements[0];
    }

    get lastElement() {
        return this.elements[this.length - 1];
    }

    get length() {
        return this.elements.length;
    }

    get isEmpty() {
        return this.length === 0;
    }
}
```


```bash
    // decks.addDeck(new TermStorage(test, "test", {is_active: true}));
    const { salesforce_experience } = require('./salesforce_certification');
    decks.addDeck(new TermStorage(salesforce_experience, "salesforce experience", { is_active: layer_2 }));

    const { python, swift, js, dart, php, java, csharp, cpp, typescript, r, matlab, kotlin } = require('./languages');
    decks.addDeck(new TermStorage(python, "python", { is_active: projects_layer }));
    decks.addDeck(new TermStorage(swift, "swift", { is_active: projects_layer }));
    decks.addDeck(new TermStorage(js, "js", { is_active: projects_layer }));
    decks.addDeck(new TermStorage(dart, "dart", { is_active: projects_layer }));
    decks.addDeck(new TermStorage(php, "php", { is_active: projects_layer }));
    decks.addDeck(new TermStorage(java, "java", { is_active: projects_layer }));
    decks.addDeck(new TermStorage(csharp, "csharp", { is_active: projects_layer }));
    decks.addDeck(new TermStorage(cpp, "cpp", { is_active: projects_layer }));
    decks.addDeck(new TermStorage(typescript, "typescript", { is_active: projects_layer }));
    decks.addDeck(new TermStorage(r, "r", { is_active: projects_layer }));
    decks.addDeck(new TermStorage(matlab, "matlab", { is_active: projects_layer }));
    decks.addDeck(new TermStorage(kotlin, "kotlin", { is_active: projects_layer }));


return decks;


```


Note the `return decks;`

From here you can view that the decks returned are: ``

Therefore I can jsut use the property: `decks` i order to fetch the count:

```js


/**
 * Follows Composition Pattern, it should be able to store other Term Storages, turn them on and off
 */
class TermStorage {

    /**
     * Initialization, by default TermStorage is acitve.
     * @param {List[JsonText]} terms Terms to be added to this deck
     * @param {string} deck_name The deckname, optional if is the parent deckname
     * @param {List[TermStorage]} decks The decks required for the Storages
     */
    constructor(terms = [], deck_name = "", { decks = [], is_active = true } = {}) {
        this.terms = terms;
        this.deck_name = deck_name;
```


## Adding the correct Quiz Settings


This is how the settings are being used


```js

if (Settings?.report_show?.performance_summary) {
    this.say(`Performance Report: ${todaydate}`, false)
    await this.performanceReport();

```



Is there any language to know their weird features? For example `c++` and how they work? How did you even get to this point in `js`? By doing couple of leetcode and projects. For that is clear that you need a language to be at least fun to play around. For `C++` I cna only seem myself improving through `Arduino`? While at least for `C#` I can get good at it because of Unity. While `Java` goes to the trash. Its just an horrible language omg.

Here a couple of languages that are used. Except for `js` and `py`. (Since I believe I have achieved significant proficiency with them. After working with them so fluently)

This is to decide which languages to work on next:

| Language   | Projects | Job Hunt | LC  | X   |
| ---------- | -------- | -------- | --- | --- |
| Flutter(D) | 8        | 2        |     | X   |
| PHP        | 6        | 6        | X   |     |
| Java       | 3        | 8        | X   |     |
| Swift      | 7        | 7        | X   | X   |
| Kotlin     | 7        | 7        | X   |     |
| Sql        | 10       | 10       |     | X   |
| C#         | 8        | 8        | X   | X   |
| C++        | 6        | 6        |     |     |

The thing about Kotlin and Swift languages is that they are barely usable only for their specific niche. Althought if I were to develop on Swift or Kotlin, I should spend more 

* For `C++` I can use it for Arduino, but also for Unreal Engine. As for job hunts it seems to appear every so often, but then they will likely to be asking for embedding systems and then you would be competiing with Electronic engineers to the mix.
* For `C#` I can use it for Unity, but also for .Net. As for job hunts it seems to appear every so often. => **GOOD**
* For `Java` I can use it for Android, but also for Spring. Howver both of them are a second option. As you have already many other languages that support such.
* For `PHP` I can use it for Laravel, but also for Wordpress. As for job hunts it seems to appear every so often. => **GOOD**
* I am already building a couple of projects in Flutter so I might as well continue improving it's syntaxt.
* For `Sql` is an absolute must. => **GOOD**


In my opinion order should be like

1. Python
2. Swift
3. C#
4. Java


My idea is to go over each of the `Dynamic Programming` questions and do them twice, once with python and then ecahc of the languages listed above.

My fear is not getting good (long term) at coding, as it is easy to learn something and not achieve greatness long term.

Python for breaking it down. And the other ones are also a good meanece. 

Then also individually practice the folllowing with some games.:

- SQL
- Pandas
- CSS


When it comes to solving them. I think is fair getting to solve them slow, and search or ask for the optimized solution.



```js

const getCommitCategories = () => {
	
}

```


What are the long term skills: For example you could indeed say that some dev + the future of.


## DSA CLI | Design


- [ ] LC


## LC Journal

### Perfect Square

- Well that s my problem , how do you find tha tperfect square?

If not found:

- Check if the number is a prime perfect Square
- Check if the number is a combination of squares
- Check if the number is a combination of previous + 1

To check if the number is a prime perfect square: We search in the i+1 of the current square

- To check if the number is a combination of squares. We loop if the distance left is larger or equal to the (from largest to smallest square found) and if it fits, we add that. and do recursively until no remainder is left.


This would take around o(n * log(n)) time. Not that bad. (The difficulty gets larger the more squares we meet, until we get to that number.) Sine we woul be getting from the last square jsut a reverse traverse works fine.


- Oh sh, that does work as epxpected! It can try either going back from frthest, but cnat get there.
- The problem here is that this is a divisible. 
- Or at least try to get some done, and fail at the attempt




| c1  | c2  | c3  |
| --- | --- | --- |
| 1   | 2   | 3   |
| 4   | 5   | 6   |
| 7   | 8   | 9   |



Down Stream
| c1  | c2  | c3  |
| --- | --- | --- |
| 1   | 2   | 3   |
| 5   | 7   | 9   |
| 12  | 15  | 18  |

Right Stream
| c1  | c2  | c3  |
| --- | --- | --- |
| 1   | 3   | 6   |
| 4   | 9   | 15  |
| 7   | 15  | 24  |


Ths is also for each row. Which should ne almost O(1) for each row. being requested. Now lets see if we can use some type of combiantion to mach? 

Lets say that the request is 1,1 to 2,2,

Then We would have 15-4 = 11 for the rows values
And then for the other values we have 24-7=17

I think it can be done just with a single stream direction.

17 + 11 = 28

Is this accurate?

5 + 6 + 8 + 9 = 28

Yes it is! 

Now lets see with a larger nnumber if that actually makes sense?

What if you want to cut before that? Then you just get that ltter one with the 


Matrix

[[[[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]], [2, 1, 4, 3], [1, 1, 2, 2], [1, 2, 2, 4]]

| row | c1  | c2  | c3  | c4  | c5  |
| --- | --- | --- | --- | --- | --- |
| r1  | 3   | 0   | 1   | 4   | 2   |
| r2  | 5   | 6   | 3   | 2   | 1   |
| r3  | 1   | 2   | 0   | 1   | 5   |
| r4  | 4   | 1   | 0   | 1   | 7   |
| r5  | 1   | 0   | 3   | 0   | 5   |





Down Stream

| row | c1  | c2  | c3  | c4  | c5  |
| --- | --- | --- | --- | --- | --- |
| r1  | 3   | 0   | 1   | 4   | 2   |
| r2  | 8   | 9   | 4   | 6   | 3   |
| r3  | 9   | 11  | 4   | 7   | 8   |
| r4  | 13  | 12  | 4   | 8   | 15  |
| r5  | 14  | 12  | 7   | 8   | 20  |


Right Stream

| rows | c1  | c2  | c3  | c4  | c5  |
| ---- | --- | --- | --- | --- | --- |
| r1   | 3   | 3   | 4   | 8   | 10  |
| r2   | 8   | 12  | 16  | 22  | 25  |
| r3   | 9   | 14  | 20  | 29  | 37  |
| r4   | 13  | 18  | 24  | 37  | 52  |
| r5   | 14  | 20  | 31  | 45  | 65  |


So lets say you want to fetch now: 

(r3, c2) and (r5, c4)


Then we do the following:

- 29 - 9  = 20
- 37 - 13 = 24
- 45 - 14 = 31

That would be all the right side view.

Because m, is just < = 200 we can consider this O(1) for each request. 

Just create a right stream.


But here I have another way to solve this:

- Set up each (r, c) with the equivalent of the right + upper values.


Then what you hae to do instead is just substract the upper section + the left section. 

After this I think whats left to work on is being useful in any way?


Having some kind of speciality: Choose
- e.g. Being great at visual projects such as html.
- Backend + Cloud: Great at cloud, SQL (Backend), Data Processing e.g. Kafka
- AI Machine Learning Specialist.

I think I will put my bet into `AI` + `Cloud` Specialization

I will putmy bet in the theoric cloud. Specialization and AI since thats whats pusshing the boundaries of research. (IMO). In my opinion if what you are looking for is a jo

Then the order of evolution should be:

1. Cloud (AWS) is good enough as long as you become grat at it.
2. AI: And that with daily speedup.


Thats reasonable on an organization level. As this are where the big speedups are once they have the MVP already ongoing.

Lets actually aim for that. 

Even for each of the projects that I stated, they are in reality cloud heavy projects

1. AI Ecommerce thing:
   1. It should be more with the speedup obtained using machine learning (thats where your focus should be at)


Because thats where the limnits of computing, alnd also where the actual computation goes into. The deep dark areas of servers, and managing hardware to achieve the next stages of computing. As well as dta security spawning from it.


Because anyone cna honestly code. But the difficult part is on the `Backend + Cloud + AI` While front end you cna usually, communicate and hire overseas teams to develop them. 

+ Database Design

- All this which affect the upper bound of the loading speeds and optimizations on a product.


**How can we use these concepts in order to further optimize processes for the next semester?**

- Stock
  - Increase the speed, Ensure testings in which everyday, you test, `login-in` and running the tests. such as creating an account for tomorrow to ensure that a certain scheduled SPLIT occurs as expected.
  - **Recommendation engine**. Based on the videos you are watching to also show the recommended stocks
    - Multifeedback system. based on other stocks seen by users that have bought the same as you.
- DSAMapping
  - Multiusers support.
  - Storage of files and showing them.
  - Modeling to support files and CSES to be widely Supported
  - AI for trainning and to test if your wordings makes any sense. Create using same backend code the requried.
- AI Presentation + Sales
  - Building a pipeline for the trainning and collecting data.
  - Build a pipeline for finding which articles to train.
  - Build pipeline for recommended top suggestions with AI as well.
  - Create fake users to simulate those pipeliens.
  - **With this you can emulate **


How about Hosting Multiple engines for  processing? What requires multiple processing? ecause most of them h ave a support (kind of ) for a slow processing engine?

Probably the sales thing might require multiple processing as you would be running perhaps multi users runs?  You can 


### Best Time to Buy and Sell Stock with Cooldown

For this, think on the following:

Check from the right side if it can sell well
Check from the left side? Whats the max profit there?


I think there is a point in which you are overdoing Algorithms.

- Most questions are only mid level, dont expect to develop some crazy hard level problem on a 50 mins session.

## Why Now just foucs on the projects?

- Because at the moment you can see that whats impeding you form getting that portfolio, done is that you feel that your portfolio is weak.
- But witht he current portfolio, you are not being headed to the right areas.


Here whats your trainning has to switch to:

- SQL Practice

## Checking if the following APIs use account_id correctly.

```js
`${APIDICT.DEPLOYED_MAID}/concept_metadata/youngests/?account_id=${account_id}&limit=${limit}`
`${APIDICT.DEPLOYED_MAID}/comment/term/${term}?format_simple=true&limit=5`;
axios.get(`${APIDICT.DEPLOYED_MAID}/account/missing_performance_today/${Settings.account_id ?? 1}`)
`${APIDICT.DEPLOYED_MAID}/account/report/${Settings.account_id ?? 1}`
`${APIDICT.DEPLOYED_MAID}/services`
`${APIDICT.DEPLOYED_MAID}/day_performance/${feature_name}?increase_score=true&value=${increaseBY}`
`${APIDICT.DEPLOYED_MAID}/concept_metadata/${problem_name}?success=${success}`

```


From what I see the main suspects are:

- POST concept/term
- POST comment/term

Clean:

- [x] `${APIDICT.DEPLOYED_MAID}/concept_metadata/youngests/?account_id=${account_id}&limit=${limit}`
- [x] `${APIDICT.DEPLOYED_MAID}/comment/term/${term}?format_simple=true&limit=5`;
- [x] GET axios.get(`${APIDICT.DEPLOYED_MAID}/account/missing_performance_today/${Settings.account_id ?? 1}`)
- [x] `${APIDICT.DEPLOYED_MAID}/account/report/${Settings.account_id ?? 1}`
- [x] `${APIDICT.DEPLOYED_MAID}/services` Doesnt Need to -> Just receives ALL
- [x] `${APIDICT.DEPLOYED_MAID}/day_performance/${feature_name}?increase_score=true&value=${increaseBY}`
- [x] POST => Fixed `${APIDICT.DEPLOYED_MAID}/concept_metadata/${problem_name}?success=${success}` 



But still ensure the following:
- Posting comments terms is using one's ids.

```js
const res = await axios.post(`${APIDICT.DEPLOYED_MAID}/day_performance/${feature_name}?increase_score=true&value=${increaseBY}&account_id=${Settings.account_id ?? 1}`)
```

It looks good. Lets check by swithcignt he account id.



https://jmmgskxdgn.us-east-1.awsapprunner.com/account/missing_performance_today/2


Missing performance is causing the error


Why is this missing?

curl -X 'GET' \
  'http://127.0.0.1:8000/account/missing_performance_today/2?select_today=true' \
  -H 'accept: application/json'



Fixed, it had to do with the default core dependencies on the daily

```py
    user_settings = {
        '1': {
            'core_performance_daily': ["feat", "math_ss", "algo", "terms", "pro", "acad", "algo_w"] #List of perfromance to be doing daily : I rather str, becuause they are understandable
        } 
    }
    if select_today or selected_date is None:
        selected_date = get_current_date()


    # 1. Get Today and query all the performance of that day as a list
    today_accomplished = set()
    total_to_accomplish = {
        'core_performance_daily': ["feat", "math_ss", "algo", "terms", "pro", "acad", "algo_w"] #List of perfromance to be doing daily : I rather str, becuause they are understandable
    }
    if account_id in user_settings:
        total_to_accomplish = user_settings[account_id]["core_performance_daily"]
    
    
```


Also have to deploy this.

## 19 - Friday

### 19.todo

- [ ] 19.1 Design DSA Web with focus on Algori beauty


### 19.1 Design DSA Web with focus on Algori beauty

- Should focus on running tests or painting maps for testing the algorithms
- Focus on the more interesting algorithms including:
  - Graphs Problems
  - Medium -> Hard Dynamic Programming
  - Machine Learning Algorithms  and tools.


For example.

DFS Problems:
- Can Tree Nodes.

Stack Problems:
- View the Stacks.
- 


This should be reserved to 



### 19.2 Calling out the Misfits.

- For those who feel behind.
- If they want experience and a network.
  

"One for All"

Policies:

- Not a parasyte: One for All
- At the start no Entry barrier. We can set up just people who feel like me. 
- Discipline is a must, you must report daily on your progress.
- Do, work show your progress daily doesnt matter if its just a screenshot.


## 23 Tuesday


### 23.todo

- [x] 23.1 Wiggle
- [ ] 23.2 Deciding on tech stack Learning
- [ ] 23.3 Combination Sum IV
- [ ] 23.4 Just an idea, about doing **hard** everyday.
- [ ] 23.5 Arithmetic Slices
- [ ] 23.6 
- [ ] 23.7 Pacific Atlantic Water Flow



### 23.1 Wiggle

- I have some ideas. Backtrack can be done.
- What it seems to happen also is that there is no sequence that can trace backk more than 3?
On each line is always conveninet to increase to the max found.
Also I was thinking if by switching, can be found.


This was mad easy to be honest. Just constantly update it. in my opinion.

Did you house-robber-X? bro.


### 23.2 Deciding on tech stack Learning


- AWS Local Stack
- Database Designing



**Reasons**

At least the following skils are really for **any** project than 

- Regardless of which project you are working on, you will need to know how to design a database.
- AWS Stack is also something that is (commonly) also shared throguh each project

What else? Theory perhaps?

There are other theories on mind. But with the avention of AWS I should absolutely focus on the data heavy aspects. As well as asttempt to get clearance for organizations when it comes to database security.

**Already in Progress**

- Algorithmic Thinking: Seasoned through LC Practice done so far. I think it is at the point in which can solve if not most of any lc problems. At least the ones that are not hard. (But will be there soon).
- Best Practices, Design Patterns: This is still being done, and we are still practicing them through Daily commits. It should be followed up on more projects.

**To set up trainning**

- Jupyter Machine Learning Tools. Thats definitively something missing
- SQL Testing tools as well. In a way, what you are trainning here could be done with local work-stack.
- You should probably focus on building those Machine learning and local stack learning opportunities. ight as well give a local task using Terminal's Postgresql
- This could also be done for `Local Stack` setting up quick environments as practice.


**What dos this mean then?**

I think we should:

1. Figure out a way to access postgresql from the command line.
2. Design the architecture for this `minimum setup` types of problems. (Check if this can be done with previous already existing architecture)
3. Create a dsa-like types of problems or cards that prompts you to perform this tasks.
4. Check if you can develop the quick-learning-fav tools

Perhaps have the environment inside of an Ubuntu VM?

You should def try to get better at wsl.x

*The idea is to build upon mini-tasks*

**Example task:**

Create a Database named `test` with the following tables:

- `users` with the following columns:
  - `id` as primary key with autoincrement
  - `name` as string required
  - `email` as string required
  - `password` as string


- `posts` with the following columns:
- `id` as primary key with autoincrement
- `title` as string
- `content` as string
- `user_id` as foreign key to `users` table

**Insert the following rows**

- `users`:
  - `id`: 1, `name`: "John", `email`: "
  - `id`: 2, `name`: "Jane", `email`: "


Now create a query that returns all the posts with the user name and email.

We can do the same with React applications. Then we should store the actual solution on a link. e.g. to a repository of a project.

With screenshtos and everything. This`task` could be desiged entirely inside of a `markdown` etc.


Or here, another React Task: 

- Start a new project
- Have a button that increases the state by 1


The idea is to have some of the most core concepts of react there.

we could be doing the same with React or Flutter.

The ideas of this labs is that eventually you should get to a very decent level at developing this mini tasks, that focus only on re-remembering core concepts. (They shoudl be self contained)


Ideally we have this tests for 

- React
- Flutter
- React Native
- Express Application
- FastAPI Application
- Simple Unity
  - Platformer
  - First Person
- Angular
- Postgresql Server.
- Certain LocalHost Contianers with certain setups or files and certain activities.
- Clone also Jupyter Notebooks activities.
- Clone and impemment Streamlit Application
- Servers using .net
- Servers using Java Spring
- Servers using Django
- Servers using Laravel
- Developing Configurations for Docker and deploying them. 


And quickly, without requriement of that memory, to finish up the project. It could be jsut the simple course and requested to complete half of it. The idea is that there shoud also be some folders with references. So it's not a memorization problem, but get used to the tools, and over time you get confident with the limits of such software and knowing that you can quickly get started in a project from your head with (best of the templates) availabels for such task. Also to create contribute, on the queality templates that you have right now. It wont work offline, but for that you can always work on other tasks such as Flashcards + DSA Trainer.


You could actually have them developing from a certain container. In which is requested to start from a template in which you cna automatically set up certain environment, forces the user to create a new branch. And requeusts the user to complete the tasks that are missing (So that not everything is basic, but you could use templates also to accelerate on Hackathons.) So the idea is that it could request you to use a certain pre-created template to strrtup a quick project. Also perhaps a contianer for certain servers to be handled on. So it could be a POSTGRES Container that you can just go in and test out.

It can also be a package of a certain project





The estimated is to have it in less than x time.






### 23.4 Just an idea, about doing **hard** everyday.


I was thinking the folllwoing what Needcode said, about doing some problems on the daily, so maybe it takes me x amount of time to accomplish that problem. But If I do, almost as an habit, or I choose lets say 1-hard question every week. Then in a year I should have almost braindead memorized 52 hard problems. I mean that memorizing would affect a lot specially for some of the best HARD problems that teaches the most. I am not talking about doing a new one. But to do from zero. 


This is how it would look like:

- I star a specific hard problem. To be done on the Journal for Maid CLI.
- Understand it at the start of the week (lets say make up an habit every Tuesday (Because I would be at school and productive))
- Then solve it from zero every day of the week.

Since many of the HARD Cool questions


**Not to be done with EVERY hard Questiosn**

Only some of the most interesting hard questions. On each topic, like a dfs porblme would be fine.

- Focus also starting from the categories you love. 


Some of the most interesting hard problems includes:

That I should aim to solve this semester (around 4*4 weeks: 16 weeks => 16 problems are)

Using this strategy we should be able to memo-cover most of the hard questions that could be used to solve other Hard Questiosn. And just cleanly pass all medium questions 

- N-Queens
- Dungeon Game
- Sudoku Solver
- Wildcard matching
- N-Queens II
- Escape a Large Maze
- Regular Expression Matching
- Word Ladder

The idea is to pass this more-real certifications that get closer to development.

## 24 Wednesday


### 24.todo
- [ ] 24.1 Pursuing Certifications


Here a pool of Certifications for Data Science:


    Certified Analytics Professional (CAP)
    Cloudera Data Platform Generalist Certification
    Data Science Council of America (DASCA) Senior Data Scientist (SDS)
    Data Science Council of America (DASCA) Principal Data Scientist (PDS)
    IBM Data Science Professional Certificate
    Microsoft Certified: Azure AI Fundamentals
    Microsoft Certified: Azure Data Scientist Associate
    Open Certified Data Scientist (Open CDS)
    SAS Certified Professional: AI and Machine Learning
    SAS Certified Advanced Analytics Professional
    SAS Certified Data Scientist
    Tensorflow Developer Certificate



- AWS Certified Solutions Architect – Associate
- AWS Certified SysOps Administrator – Associate
- AWS Certified DevOps Engineer – Professional
- AWS Certified Solutions Architect – Professional
- IBM Data Science Professional Certificate
- Oracle Certified Master: 3 years

Definitively if I follow this path I could highly use them on the job.

With those certifications I could be improving drastically the chances 


Also some weird certifications badges that I could just attempt to follow, and then paste it on the resume, like some kind of product.


And here a Cloud Certifications path I would like to follow:

- AWS Certified Cloud Practitioner
- AWS Certified Developer – Associate
- Salesforce Administrator
- Tensorflow Developer Certificate

Also as for when it comes to tech that will be reasonably sustainable on the long term (no AI competition) Cloud + AI + IT + Administration are the ones that as they usually are more on the backend side. And it also usually very much connected to some topics on CS, including how computing and Systems work. I see them all as an extension from the base learned on CS. (Not some flashy Certfication, but they (usually build upon the contents.))

And the joke is that it will be certs + projects + Algo knowledge (completed, now illbe more in the mantainance side)

**Daily Plan**


- [ ] Advance on Work Project
- [ ] Follow up with DSA 
- [ ] Follow up by going thorough AWS Certification Course.
- [ ] Follow up by building open source
- [ ] At night, follow up by explaining some of the topics you learnt in person.


**Weekly Plan**

- [ ] Complete and Memo 1 Hard Question x Week.
- [ ] 

- The idea when collecting cards is:
  - Find out which is the topic scope of the question
  - Find the wrapping topic of the question
  - You should probably do that for All items you face on. Find the wrapping topic in question and research neighborhood topics. Should do this also with Interview Questions of language/Feature as well.

- PRobably do the same with with School Topics, Search online try to understand them by your own. Then take the classes.


**Explainning Topics**

- The idea is using the current topics for something.


Prioritization of this topics by certification is key, because it is easier to test for gaps of knowledge, also is accredited and can show within a resume length. Also prove that you were accreditaated and pass certain bar proposed by other organizations.

- You should do the same with interview languages questions. As from seen last time, they are at least a basic layer over a specific language.


Then you have the long term questions.

- [ ] The idea is for this questions to be a base where to build upon. (Of course only doable with skills you been practicing for a while)

**Considerations**

- Apply to the same tech and offer that as a service.
- Daily Mock Interview on demand











































